12/23： 目前value状态设置还有问题，目前的设计如下图所示：
状态转换图
     接收新VPB/创世
          ↓
      [UNSPENT]
          ↓ 选中用于交易
      [SELECTED] ←─────┐
          ↓ 提交交易    │ 回滚
   [LOCAL_COMMITTED]   │
          ↓ 链上确认    │
      [CONFIRMED] ─────┘
         (已花费)

预计修改为以下几种状态：
1）UNSPENT：未花费状态，表示该value尚未被用于任何交易。
2）PENDING：待确认状态，表示该value已被用于交易，但交易尚未被区块链网络确认。
3）CONFIRMED：已确认状态，表示该value已被用于交易，并且

12/22目前多轮测试还有清结算bug，例如：
仅是多轮中的第一轮：
✅ Account david 创建交易 → bob, 金额: 1700
✅ Account charlie 创建交易 → david, 金额: 1500
✅ Account alice 创建交易 → bob, 金额: 1700
------------
最后结果：
   🔴 CONFIRMED:  4 values, Amount:   1700
   🟢 UNSPENT: 18 values, Amount:    605

   🟢 UNSPENT: 24 values, Amount:   4305 （应该是5705，少1400）

   🔴 CONFIRMED:  2 values, Amount:   1500
   🟢 UNSPENT: 20 values, Amount:    805

   🔴 CONFIRMED:  4 values, Amount:   1700
   🟢 UNSPENT: 19 values, Amount:   1605（应该是2105，少500）



12/17：update_after_transaction_sent方法更新，将先前的方法作为旧方法弃用。
新的update_after_transaction_sent还未测试，老方法的调用还未调整为新方法。

verify_vpb_pair调用时，block_index_list就有错误了（应该是在695行代码时就出错了）。

12/16：
test_blockchain_integration_with_real_account.py的日志输出显示：
步骤6.3 接收者同步处理中，在验证VPB合法性环节，每个发送者account的第一个接收者都会验证VPB成功，但是此account的随后的接收者都会验证失败，例如（我运行一次的案例）：
 处理发送者 alice 的 4 个接收者...
      🔍 验证VPB合法性: david 接收金额 100
         ✅ VPB验证成功
Receiving VPB for 0xc2f6704b77f4ee5e3e7e79630e81c1ffc71fd104 from other account...
Value 0x1640 does not exist, adding new value...
Added received value mapping to ProofManager for node_id: 579dbd2c-f818-40a1-8ff8-12d6b506da23
VPB reception completed successfully for value 0x1640
         ✅ VPB接收成功，david 本地数据已更新
      🔍 验证VPB合法性: charlie 接收金额 10
         ❌ VPB验证失败 (共2个错误):
            1. NO_VALID_TARGET_VALUE_TRANSFER @区块1
               Block 1 must contain valid target value transfer from 0x134599aeb1582bde22b7a...
            2. INVALID_TARGET_VALUE_INTERSECTION @区块1
               Invalid target value intersection found in block 1: <EZ_Transaction.SingleTra...
      🔍 验证VPB合法性: bob 接收金额 10
         ❌ VPB验证失败 (共2个错误):
            1. NO_VALID_TARGET_VALUE_TRANSFER @区块1
               Block 1 must contain valid target value transfer from 0x134599aeb1582bde22b7a...
            2. INVALID_TARGET_VALUE_INTERSECTION @区块1
               Invalid target value intersection found in block 1: <EZ_Transaction.SingleTra...
      🔍 验证VPB合法性: bob 接收金额 1
         ❌ VPB验证失败 (共2个错误):
            1. NO_VALID_TARGET_VALUE_TRANSFER @区块1
               Block 1 must contain valid target value transfer from 0x134599aeb1582bde22b7a...
            2. INVALID_TARGET_VALUE_INTERSECTION @区块1
               Invalid target value intersection found in block 1: <EZ_Transaction.SingleTra...
...
🔍 处理发送者 david 的 2 个接收者...
      🔍 验证VPB合法性: charlie 接收金额 100
         ✅ VPB验证成功
Receiving VPB for 0xef5889f585fec4b496efc7df3fd1fbc182cef216 from other account...
Value 0x320b does not exist, adding new value...
Added received value mapping to ProofManager for node_id: b3fc3429-1e71-43bb-aff2-4293ad615a58
VPB reception completed successfully for value 0x320b
         ✅ VPB接收成功，charlie 本地数据已更新
      🔍 验证VPB合法性: alice 接收金额 1
         ❌ VPB验证失败 (共2个错误):
            1. NO_VALID_TARGET_VALUE_TRANSFER @区块1
               Block 1 must contain valid target value transfer from 0xc2f6704b77f4ee5e3e7e7...
            2. INVALID_TARGET_VALUE_INTERSECTION @区块1
               Invalid target value intersection found in block 1: <EZ_Transaction.SingleTra...

总结
通过添加调试日志并分析问题，我发现了VPB验证失败的根本原因：
问题根源
交易数据和VPB数据不匹配导致的验证失败 具体表现为：
David创建交易时：将某个原本应该属于Alice的value（begin_index=0x33eb, end_index=0x33f4, value_num=10）错误地转给了Bob
Alice验证VPB时：期望接收这个value，但实际交易中的接收者是Bob而不是Alice
验证器检查时发现：
发送者正确：David ✓
Value匹配：正确 ✓
接收者错误：期望是Alice，实际是Bob ❌
问题出现在哪里
这个问题的根源在于交易创建和VPB数据准备之间的不一致性：
在交易打包阶段（create_transactions_from_accounts方法中），Account创建交易时可能存在Value选择或交易接收者设置的错误
在VPB数据准备阶段（步骤6.3中），为接收者准备的VPB数据与实际交易内容不匹配


12/12 目前proof_validator_04.py验证仍有问题，直接错误出现在：
# 验证重建的SubmitTxInfo哈希是否匹配Merkle证明叶子节点
                    expected_leaf_hash = reconstructed_submit_tx_info.multi_transactions_hash
                    actual_leaf_hash = genesis_proof_unit.owner_mt_proof.mt_prf_list[0]
二者不对应。

EZchain 项目中 test_blockchain_integration_with_real_account.py 测试的深入调查，我发现了 VPB 验证失败的深层次原因。以下是详细的调查报告：
1. 错误现象
测试运行时出现以下错误：
2025-12-12 10:16:57,398 - VPBValidator - WARNING - VPB validation failed with 3 errors
错误: GENESIS_PROOF_VERIFICATION_FAILED - Genesis block proof verification failed: Merkle proof leaf hash mismatch: expected '6ebbe9dd1bcf63131a61c524b4d9d9cf5684cb4728536dfdeeaa8ba82a5afb70', got '073e9095f204a8f15115cc0c99541d33ca47fe4fe07d655e67c6d47a61c9e6cf'
错误: PROOF_UNIT_VERIFICATION_FAILED - Proof unit verification failed at block 0: Merkle proof leaf hash mismatch: expected '6ebbe9dd1bcf63131a61c524b4d9d9cf5684cb4728536dfdeeaa8ba82a5afb70', got '073e9095f204a8f15115cc0c99541d33ca47fe4fe07d655e67c6d47a61c9e6cf'
错误: PROOF_UNIT_VERIFICATION_FAILED - Proof unit verification failed at block 1: Merkle proof leaf hash mismatch: expected '36ff59921032e829b4de9d84ad5e165b0edd1642adb4f5f48e5d027bb6f70c87', got '76ca117c892800c0c415302866e9b8c8e9f60a92d305d66917b6268f5317c0fe'
2. 根本原因分析
通过详细的代码分析和添加调试日志，我发现了问题的根本原因： 数据结构层次不一致：
生成层: MultiTransactions → SubmitTxInfo → Merkle tree (基于 SubmitTxInfo hash 构建)
验证层: MultiTransactions digest → Expected Merkle proof leaf (digests hash)
不匹配: Merkle proof 实际包含的是 SubmitTxInfo hashs hash，而不是 MultiTransactions digests hash
3. 具体技术细节
创世块创建过程：
在 EZ_GENESIS/genesis.py:509 中，Merkle树使用 SubmitTxInfo 的 hash 构建：
submit_tx_hashes = [submit_tx_info.get_hash() for submit_tx_info in genesis_submit_tx_infos]
在 EZ_VPB_Validator/steps/proof_validator_04.py:230 中，验证时期望的是 MultiTransactions digest 的哈希：
expected_leaf_hash = sha256_hash(genesis_proof_unit.owner_multi_txns.digest)
调试信息验证： 通过添加的调试日志，我确认了以下不一致：
MultiTransactions digest: 9cdffb07e17ed5c4a590598a73c0ee84eb2e76c65273e77c8cda0e6797118472
Expected leaf hash (sha256 of digest): f055877fdafa5b3d39d7e46a2837e377b6b0af939201dc6243dd555d4a9e0a01
Actual leaf hash (proof[0]): 8b1f67dca725e3973d0d6c0f9d341898799b78af3a10ad7bcdc6c85115212113

12/12 由于目前最新是采用向交易池提交submit_tx_info，而不是multi_transactions本体，
因此在test_blockchain_integration_with_real_account.py中，步骤6.2及6.3后续的检查，
是有问题的。最重要的是缺少了submit_tx_info与multi_transactions之间的转换过程。
需要在account中添加相关方法，完成submit_tx_info到multi_transactions的转换检测。
目前构建默克尔书证明是基于submit_tx_info的，但multi_transactions本体才是最终的交易集合，用于检测双花等。
因此submit_tx_info与multi_transactions之间的转换过程检查是必要的。

12/11 运行test_blockchain_integration_with_real_account报错，猜测是其调用的VPBManager中的
initialize_from_genesis_batch方法有问题：
其# 3. 优化ProofUnits添加 - 使用批量操作避免不必要的嵌套循环
            # 构建value_proof_pairs列表用于批量添加
是否是在批量添加时出现了问题，应该使用统一的接口进行添加？
待修复。


12/9 最新的proofs的架构（利用account proof manager 管理所有proof units）与vpb检验器的架构接口不一致有冲突。


11/21：目前的vpb_updater的更新逻辑还是有问题的，例如下面两点：
1）_get_account_vpbs函数并未真正实现读取账户本地vpb功能
2）实际的更新并非是将所有vpb列表读取进内存然后挨个更新，而是一种更巧妙的方式，具体地，可详细阅读Proofs.py及Proof readme.md。
其采用了一种映射方案来减少内存占用和提高更新效率，因此在跟新vpb中的p（Proofs）时，并不需要把所有proof unit读入内存，
而是更新相关映射关系即可。因此，当前的vpb_updater逻辑并不适用，需要进行调整。

11/22：vpb待重构。

11/27：已完成genesis创建，test_blockchain_integration_with_real_account.py测试待修复。


12/3：test_blockchain_integration_with_real_account.py测试中test_complete_real_account_transaction_flow中：
步骤6到步骤7中缺少一些具体过程：例如：
1）miner向account（交易的sender）发送vpb更新相关数据包（通过miner的prepare_vpb_distribution_data方法）
2）sender本地化处理（通过account的update_vpb_after_transaction_sent方法）
3）sender发送vpb给recipient（通过account的receive_vpb_from_others方法）
4）recipient本地验证（通过VPBValidator类）

12/3：修改的pick_transactions_from_pool_with_proofs，还未设计测试。【ok】

12/4：目前pick_transactions_from_pool_with_proofs测试在6.2步骤有问题，具体地：
# 获取发送者的相关交易数据
if hasattr(submit_tx_info, 'multi_transactions') and submit_tx_info.multi_transactions:
这里想要从submit_tx_info中提取multi_transactions本体，但这是错的。
应当在account本地中提取对应信息，目前正在编制account相关方法（提交交易池缓冲队列），待完成。

12/6：
运行test_blockchain_integration_with_real_account测试输出：
📋 交易请求详情:
  第1轮 (8笔交易):
    charlie → alice: 100
    alice → bob: 100
    alice → charlie: 10
    alice → charlie: 50
    alice → bob: 100
    bob → alice: 100
    charlie → bob: 100
    charlie → david: 10

这里Alice作为发送者确实有3笔交易：
alice → bob: 100
alice → charlie: 10
alice → charlie: 50

但是在6.2步骤中显示：
🔍 检查提交交易: alice_real_address_000
   - 从account本地获取multi_txns成功，包含 6 个交易

问题来了：为什么显示6个交易而不是3个？

找到问题了！ 在 CreateMultiTransactions.create_multi_transactions 方法中，我发现了关键的代码： 第108-126行：Change Transaction 逻辑
# Handle change transaction if needed
change_txn_obj = None
if change_value:
    change_transaction = Transaction(
        sender=self.sender_address,
        recipient=self.sender_address,  # 找零给自己
        nonce=nonce,
        signature=None,
        value=[change_value],
        time=timestamp
    )
    # Sign the change transaction
    change_transaction.sig_txn(private_key_pem)
    change_txn_obj = change_transaction
    change_values_list.append(change_value)

transactions.append(main_transaction)
if change_txn_obj:
    transactions.append(change_txn_obj)  # 这里是关键！

根因分析结果
问题不是Bug，而是VPB系统的找零机制导致的正常行为！
交易拆分逻辑解释：
Alice的3笔交易请求：
alice → bob: 100
alice → charlie: 10
alice → charlie: 50
VPB值选择机制：每笔交易都需要选择合适的Value来凑够金额，这会产生找零
找零交易：每笔交易如果需要找零，都会创建一个额外的找零交易（Alice → Alice）
实际交易数量计算：
主交易：3笔（给Bob和Charlie的）
找零交易：可能3笔（每笔主交易对应一笔找零）
总计：6笔交易（正好匹配输出中的数量）
为什么是6笔交易？
Alice的每笔交易都可能触发了VPB的找零机制：
alice → bob: 100 → 可能需要1个找零交易
alice → charlie: 10 → 可能需要1个找零交易
alice → charlie: 50 → 可能需要1个找零交易
总计：3 + 3 = 6笔交易
结论
这不是一个Bug，而是VPB（Value Proof Block）系统的正确工作方式。系统为了保证交易的精确性，
会为每笔需要找零的主交易创建额外的找零交易，这些找零交易也记录在Alice的MultiTransactions中。
输出中显示的"6个交易"是准确的，包含了3笔主交易和3笔找零交易。